
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>HW7</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-11-15"><meta name="DC.source" content="HW7.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">problem 3 forward Euler to solve an IVP</a></li><li><a href="#4">problem 4 Backwards Euler</a></li><li><a href="#5">problem 5</a></li><li><a href="#7">C) generate a convergence plot for an order 4 BDF which approximates the</a></li><li><a href="#8">compare BDF order 4 to Backwards Euler</a></li></ul></div><pre class="codeinput"><span class="comment">%Author: Alex Dawson-Elli</span>
<span class="comment">%project: ME 751 hw 7</span>
<span class="comment">%date 10.28.2016</span>
</pre><h2>problem 3 forward Euler to solve an IVP<a name="2"></a></h2><p>theoretically ,we define the region of stability for forward euler as abs(1+h*lambda)&lt; 1. This fell out of the definition of forward euler and the condition that the numerical solution of the decaying exponential mirror the behavior of the analyitcal solution, in that y_n+1 &lt; y_n</p><pre class="codeinput"><span class="comment">%using the above inequality, it follow that the theoretical regions of</span>
<span class="comment">%stability for the three values of lambda are:</span>
<span class="comment">%   lambda = -10    -&gt;  0&lt;h&lt;.2</span>
<span class="comment">%   lambda = -100   -&gt;  0&lt;h&lt;.02</span>
<span class="comment">%   lambda = -1000  -&gt;  0&lt;h&lt;.002</span>

<span class="comment">%The bondries of instability for each value of lambda will be demonstrated</span>
<span class="comment">%numerically below</span>

<span class="comment">%constants and function definitions</span>
h_step = .0001;   <span class="comment">%1/1000 sec time step</span>
t_end = 2;       <span class="comment">%final time, 2 seconds (arbitrary choice)</span>
y0 = 1;
lambdaVect = [-10, -100, -1000];
txt = <span class="string">'largest stable value of h'</span>;
stable = true;
y_n = y0;
y_np1 = 0;       <span class="comment">%n plus one</span>

<span class="comment">%solution</span>
<span class="keyword">for</span> i = 1:3
    <span class="comment">%find h_max for each lambda , i</span>
    stable = true;     <span class="comment">%display previous h_max</span>
    h_step = .0001;   <span class="comment">%rest h_step</span>

    <span class="keyword">while</span>(stable)<span class="comment">%incrementally increase h step until instability</span>
         y_n = y0;
         y_np1 = 0;

        <span class="keyword">for</span> t = h_step:h_step:t_end; <span class="comment">%numerically solve first 2 seconds</span>
            y_np1 = y_n + h_step*lambdaVect(i)*y_n;

            <span class="comment">% check if system is stable</span>
            <span class="keyword">if</span>(abs(y_np1) &gt; abs(y_n))
                stable = false;
                h_max =h_step;
            <span class="keyword">end</span>

            <span class="comment">%perform next itteration</span>
            y_n = y_np1;
        <span class="keyword">end</span>

         <span class="comment">%increase h_step incrementally to find where unstable</span>
         h_step = h_step + .0001;
         <span class="comment">%disp(h_step)</span>

    <span class="keyword">end</span>
    display(lambdaVect(i));
    disp(h_max);


<span class="keyword">end</span>
</pre><pre class="codeoutput">
ans =

   -10

    0.2001


ans =

  -100

    0.0201


ans =

       -1000

    0.0020

</pre><p>as can be seen above, the numerical solutions agree nicely with the theoretical solutions calculated earlier</p><h2>problem 4 Backwards Euler<a name="4"></a></h2><p>we are asked to apply backwards Euler to solve the IVP over the interval 0&lt;t&lt;20. Backwards Euler is defined itteratively as xn = x_n-1 + h*xdotn. it offeres the advantage over forward Euler of being stable, for greater h step sizes, at the expense of solving a non-linear equation at each itterative step.</p><pre class="codeinput"><span class="comment">%constants:</span>
alpha = 0;
beta = 1;
epsilon =.0001;  <span class="comment">%accuracy requirements of newton rapson</span>
h = .01;         <span class="comment">%step size in seconds</span>

<span class="comment">%initial conditions:</span>
x0 = 0;
y0 = 2;
Y_nm1 = [x0 , y0]'; <span class="comment">%2x1 vector</span>

<span class="comment">%function definitions</span>
xdot = @(x,y) alpha - x - 4*x*y/(1+x^2);
ydot = @(x,y) beta*x*(1- y/(1+ x^2));

<span class="comment">%plot variables:</span>
t = 0:.01:20;
xt = zeros(length(t),1);
yt = zeros(length(t),1);

<span class="comment">%solve for y and x over the period 0&lt;t&lt;20, with step h</span>
i = 1;  <span class="comment">%loop counter</span>
<span class="keyword">for</span> t = h:h:20 <span class="comment">%start:step:stop</span>

    <span class="comment">%use forward euler to generate first guess of Y_n</span>
    x = Y_nm1(1); <span class="comment">%x_nm1 in more readable form</span>
    y = Y_nm1(2); <span class="comment">%y_nm1 in more readable form</span>
    Y_n = [ x + h*xdot(x,y) , y + h*ydot(x,y) ]';

    <span class="comment">%set delta large</span>
    delta = [1,1];

     <span class="comment">%newton rapson iterations -&gt; J*delta = -G</span>
    <span class="keyword">while</span>(norm(delta) &gt; epsilon)
        <span class="comment">% 2x1           2x2                           2x1</span>
        delta = (NR.J(h,Y_n,beta))^-1  * -NR.G(h,Y_nm1,Y_n,alpha, beta);
        Y_n = Y_n + delta;
    <span class="keyword">end</span>

    <span class="comment">% append values to plot variables</span>
    xt(i) = Y_n(1);
    yt(i) = Y_n(2);
    i = i + 1;

    <span class="comment">%increment y</span>
    Y_nm1 = Y_n;

<span class="keyword">end</span>

<span class="comment">%plot x,y,t</span>
<span class="comment">% plot(t,xt);</span>
<span class="comment">% hold on;</span>
<span class="comment">% plot(t,yt);</span>


<span class="comment">%at the supplied initial conditions, the values for xdot and ydot evaluate</span>
<span class="comment">%to zero. because of this, the value of the function Y_n doesn't change as</span>
<span class="comment">%we advance time, which makes the solution uninteresting. I could have a</span>
<span class="comment">%bug in the code, but I'm not seeing it at the moment, and it does appear</span>
<span class="comment">%that xdot and ydot evaluate to  zero given the initial conditions, which</span>
<span class="comment">%would lead to X_np1 = xn.</span>
</pre><h2>problem 5<a name="5"></a></h2><pre class="codeinput"><span class="comment">%in problem 5, we are given a first order differential equation, and asked</span>
<span class="comment">%to solve it using backwards Euler, and BDF</span>

<span class="comment">%a) prove that y(t) = 1/t + 1/t^2*tan((1/t + pi -1))</span>
<span class="comment">%solution: if y(t) is the exact solution to the IVP, then y(1)=1, and the</span>
<span class="comment">%derivative of y(t) will equal ydot:</span>
<span class="comment">%   plugging t = 1 into y(t) results in 1 + 1*tan(pi) = 1 + 0 = 1, which</span>
<span class="comment">%   checks out</span>

<span class="comment">%taking the derivative of y, we get the following expression for ydot</span>
imshow(<span class="string">'ydot.png'</span>);

<span class="comment">%this is equivalent to the value of  -y^2 - 1/t^4, if we substitute in</span>
<span class="comment">%tan^2(theta) = 1 + sec^2(theta)</span>
imshow(<span class="string">'ysqrd.png'</span>);

<span class="comment">%b)generate a convergence plot using backwards euler</span>
</pre><img vspace="5" hspace="5" src="HW7_01.png" alt=""> <pre class="codeinput"><span class="comment">%constants:</span>
h = [.05 .01 .005 .001]; <span class="comment">%decreasing values of h</span>
tStart =1; <span class="comment">%sec</span>
tEnd = 10; <span class="comment">%sec</span>
epsilon =.0001;
<span class="comment">%initial conditions:</span>
y1 = 1;
y_n = y1;
<span class="comment">%function definitions</span>
y_ana = @(t)  1/t + 1/t^2*(tan(1/t + pi -1)); <span class="comment">%analytical expression for y</span>
ydot  = @(y,t) -y^2 - 1/t^4;
jac   = @(y_np1,h) 1 + 2*y_np1*h; <span class="comment">%jacobian</span>
g     = @ (y_np1,y_n,h,t) y_np1 - y_n + h*(y_np1^2 + 1/t^4);


<span class="keyword">for</span> i = 1:length(h);

<span class="comment">%reset initial conditions</span>
y_n = y1;

<span class="comment">%plot variables:</span>
tVect = tStart:h(i):tEnd;
yt = zeros(length(tVect),1);
j = 1; <span class="comment">%plot counter</span>


<span class="keyword">for</span> t = tStart:h(i):tEnd <span class="comment">%start:step:stop</span>

    <span class="comment">%use forward euler to generate first guess of Y_n</span>
    y_np1 = y_n + h(i)*ydot(y_n,t);

    <span class="comment">%set delta large</span>
    delta = 1;

     <span class="comment">%newton rapson iterations -&gt; J*delta = -G</span>
    <span class="keyword">while</span>(delta &gt; epsilon)
        <span class="comment">% 1x1           1                           1x1</span>
        delta = jac(y_np1,h(i))^-1  * -g(y_np1,y_n,h(i),t + h(i));
        y_np1 = y_np1 + delta;
    <span class="keyword">end</span>

    <span class="comment">% append values to plot variables</span>
    yt(j) = y_np1;
    j = j + 1;

    <span class="comment">%increment y</span>
    y_n = y_np1;

<span class="keyword">end</span>

<span class="comment">%store difference between final numerical and analytical solution</span>
error1(i) = abs(y_ana(t) - y_n);

<span class="comment">% %plot x,y,t</span>
<span class="comment">% hold on</span>
<span class="comment">% plot(tVect,yt);</span>
<span class="comment">% title('numerical approximations of decreasing step size h')</span>

<span class="keyword">end</span>

figure;
plot(log2(h),log2(error1), <span class="string">'-bs'</span>);
title(<span class="string">'convergence Analysis, Backwards Euler'</span>)
xlabel(<span class="string">'log2(h)'</span>)
ylabel(<span class="string">'log2(error) @ t = 10 seconds'</span>)
</pre><img vspace="5" hspace="5" src="HW7_02.png" alt=""> <h2>C) generate a convergence plot for an order 4 BDF which approximates the<a name="7"></a></h2><pre class="codeinput"><span class="comment">%solution of the above IVP</span>

<span class="comment">%BDF co-efficients:</span>
A = [48/25 -36/25 16/25 -3/25]; <span class="comment">%alpha values</span>
B = [12/25]; <span class="comment">%beta values</span>

<span class="comment">%constants:</span>
h = [.05 .01 .005 .001]; <span class="comment">%decreasing values of h</span>
tStart =1; <span class="comment">%sec</span>
tEnd = 10; <span class="comment">%sec</span>
epsilon =.0001;

<span class="comment">%initial conditions:</span>
y1 = 1;

<span class="comment">%functions</span>
y_ana = @(t)  1/t + 1/t^2*(tan(1/t + pi -1)); <span class="comment">%analytical expression for y</span>
ydot  = @(y_n,t) -y_n^2 - 1/t^4;
jac   = @(y_n,h) 1 + h*12/25*2*y_n; <span class="comment">%jacobian = d/dy_n(g)</span>
g     = @(y,h,t,n) y(n) - A(1)*y(n-1) - A(2)*y(n-2) - A(3)*y(n-3) - A(4)*y(n-4) - B*h*ydot(y(n), t);

<span class="keyword">for</span> i = 1:length(h);

<span class="comment">%reset initial conditions and plot variables</span>
tVect = tStart:h(i):tEnd;
y = zeros(length(tVect),1);
j = 1; <span class="comment">%plot counter</span>
n = 5; <span class="comment">%5th time step</span>
tstart = tStart + n * h(i); <span class="comment">%start BDF at 5th time step</span>

<span class="comment">%use the analytical solution to prime the BDF method</span>
<span class="keyword">for</span> ind = 1:4
    y(ind) = y_ana(tStart + (ind - 1)*h(i));
<span class="keyword">end</span>

<span class="keyword">for</span> t = tstart:h(i):tEnd <span class="comment">%start:step:stop</span>

    <span class="comment">%use forward euler to generate first guess of Y_n</span>
    y(n) = A(1)*y(n-1) + A(2)*y(n-2) + A(3)*y(n-3) + A(4)*y(n-4) + B*h(i)*ydot(y(n-1),(t - h(i)));

    <span class="comment">%set delta large</span>
    delta = 0;

     <span class="comment">%newton rapson iterations -&gt; J*delta = -G</span>
    <span class="keyword">while</span>(abs(delta) &gt; epsilon)
        <span class="comment">% 1x1           1                           1x1</span>
        delta = jac(y(n),h(i))^-1  * -g(y,h(i),t,n);
        y(n)= y(n) + delta;
    <span class="keyword">end</span>

    <span class="comment">%increment n</span>
    n = n + 1;

<span class="keyword">end</span>

<span class="comment">%store difference between (4th)from final numerical and analytical solution</span>
error2(i) = abs(y_ana(t -4*h(i)) - y(n-4));

<span class="comment">% %plot x,y,t</span>
<span class="comment">% hold on</span>
<span class="comment">% plot(tVect,y);</span>
<span class="comment">% title('numerical approximations of decreasing step size h')</span>

<span class="keyword">end</span>

<span class="comment">%figure;</span>
plot(log2(h),log2(error2), <span class="string">'-rs'</span>);
title(<span class="string">'convergence Analysis BDF order 4'</span>)
xlabel(<span class="string">'log2(h)'</span>)
ylabel(<span class="string">'log2(error) @ t = 10 seconds'</span>)
</pre><img vspace="5" hspace="5" src="HW7_03.png" alt=""> <h2>compare BDF order 4 to Backwards Euler<a name="8"></a></h2><pre class="codeinput"><span class="comment">%by inspection, the BDF of order 4 seems to have less error at the same</span>
<span class="comment">%step size the slopes seem to converging, like the lines will cross at high</span>
<span class="comment">%step size</span>

plot(log2(h),log2(error2), <span class="string">'-rs'</span>);
title(<span class="string">'convergence Analysis BDF order 4'</span>)
xlabel(<span class="string">'log2(h)'</span>)
ylabel(<span class="string">'log2(error) @ t = 10 seconds'</span>)

hold <span class="string">on</span>

plot(log2(h),log2(error1), <span class="string">'-bs'</span>);
title(<span class="string">'convergence Analysis, Backwards Euler'</span>)
xlabel(<span class="string">'log2(h)'</span>)
ylabel(<span class="string">'log2(error) @ t = 20seconds'</span>)
</pre><img vspace="5" hspace="5" src="HW7_04.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%Author: Alex Dawson-Elli
%project: ME 751 hw 7
%date 10.28.2016



%% problem 3 forward Euler to solve an IVP
% theoretically ,we define the region of stability for forward euler as 
% abs(1+h*lambda)< 1. This fell out of the definition of forward euler
% and the condition that the numerical solution of the decaying exponential 
% mirror the behavior of the analyitcal solution, in that y_n+1 < y_n

%using the above inequality, it follow that the theoretical regions of 
%stability for the three values of lambda are: 
%   lambda = -10    ->  0<h<.2
%   lambda = -100   ->  0<h<.02
%   lambda = -1000  ->  0<h<.002

%The bondries of instability for each value of lambda will be demonstrated
%numerically below

%constants and function definitions
h_step = .0001;   %1/1000 sec time step
t_end = 2;       %final time, 2 seconds (arbitrary choice)
y0 = 1;
lambdaVect = [-10, -100, -1000];
txt = 'largest stable value of h';
stable = true;
y_n = y0;
y_np1 = 0;       %n plus one

%solution
for i = 1:3
    %find h_max for each lambda , i
    stable = true;     %display previous h_max
    h_step = .0001;   %rest h_step
    
    while(stable)%incrementally increase h step until instability
         y_n = y0;
         y_np1 = 0;

        for t = h_step:h_step:t_end; %numerically solve first 2 seconds
            y_np1 = y_n + h_step*lambdaVect(i)*y_n; 
           
            % check if system is stable
            if(abs(y_np1) > abs(y_n)) 
                stable = false;
                h_max =h_step;
            end
            
            %perform next itteration
            y_n = y_np1;
        end

         %increase h_step incrementally to find where unstable
         h_step = h_step + .0001;
         %disp(h_step)
           
    end 
    display(lambdaVect(i));
    disp(h_max); 
       
        
end
%% 
% as can be seen above, the numerical solutions agree nicely with the 
% theoretical solutions calculated earlier

%% problem 4 Backwards Euler 
% we are asked to apply backwards Euler to solve the IVP over the interval
% 0<t<20. Backwards Euler is defined itteratively as xn = x_n-1 + h*xdotn.
% it offeres the advantage over forward Euler of being stable, for greater
% h step sizes, at the expense of solving a non-linear equation at each 
% itterative step. 

%constants:
alpha = 0;
beta = 1;
epsilon =.0001;  %accuracy requirements of newton rapson
h = .01;         %step size in seconds

%initial conditions:
x0 = 0;
y0 = 2;
Y_nm1 = [x0 , y0]'; %2x1 vector

%function definitions
xdot = @(x,y) alpha - x - 4*x*y/(1+x^2);
ydot = @(x,y) beta*x*(1- y/(1+ x^2));

%plot variables:
t = 0:.01:20;
xt = zeros(length(t),1);
yt = zeros(length(t),1);

%solve for y and x over the period 0<t<20, with step h
i = 1;  %loop counter
for t = h:h:20 %start:step:stop
    
    %use forward euler to generate first guess of Y_n
    x = Y_nm1(1); %x_nm1 in more readable form
    y = Y_nm1(2); %y_nm1 in more readable form
    Y_n = [ x + h*xdot(x,y) , y + h*ydot(x,y) ]';
    
    %set delta large
    delta = [1,1];
    
     %newton rapson iterations -> J*delta = -G
    while(norm(delta) > epsilon)
        % 2x1           2x2                           2x1
        delta = (NR.J(h,Y_n,beta))^-1  * -NR.G(h,Y_nm1,Y_n,alpha, beta); 
        Y_n = Y_n + delta;
    end
    
    % append values to plot variables
    xt(i) = Y_n(1);
    yt(i) = Y_n(2);
    i = i + 1;
    
    %increment y
    Y_nm1 = Y_n;
   
end

%plot x,y,t
% plot(t,xt);
% hold on;
% plot(t,yt);


%at the supplied initial conditions, the values for xdot and ydot evaluate
%to zero. because of this, the value of the function Y_n doesn't change as
%we advance time, which makes the solution uninteresting. I could have a
%bug in the code, but I'm not seeing it at the moment, and it does appear
%that xdot and ydot evaluate to  zero given the initial conditions, which
%would lead to X_np1 = xn.

%% problem 5  
%in problem 5, we are given a first order differential equation, and asked
%to solve it using backwards Euler, and BDF

%a) prove that y(t) = 1/t + 1/t^2*tan((1/t + pi -1))
%solution: if y(t) is the exact solution to the IVP, then y(1)=1, and the
%derivative of y(t) will equal ydot:
%   plugging t = 1 into y(t) results in 1 + 1*tan(pi) = 1 + 0 = 1, which
%   checks out

%taking the derivative of y, we get the following expression for ydot
imshow('ydot.png');

%this is equivalent to the value of  -y^2 - 1/t^4, if we substitute in 
%tan^2(theta) = 1 + sec^2(theta)
imshow('ysqrd.png');

%b)generate a convergence plot using backwards euler
%%
%constants:
h = [.05 .01 .005 .001]; %decreasing values of h
tStart =1; %sec
tEnd = 10; %sec
epsilon =.0001;
%initial conditions:
y1 = 1;
y_n = y1;
%function definitions
y_ana = @(t)  1/t + 1/t^2*(tan(1/t + pi -1)); %analytical expression for y
ydot  = @(y,t) -y^2 - 1/t^4;
jac   = @(y_np1,h) 1 + 2*y_np1*h; %jacobian
g     = @ (y_np1,y_n,h,t) y_np1 - y_n + h*(y_np1^2 + 1/t^4);   
 

for i = 1:length(h);

%reset initial conditions    
y_n = y1;

%plot variables:
tVect = tStart:h(i):tEnd;
yt = zeros(length(tVect),1);
j = 1; %plot counter
   
    
for t = tStart:h(i):tEnd %start:step:stop
    
    %use forward euler to generate first guess of Y_n
    y_np1 = y_n + h(i)*ydot(y_n,t);
    
    %set delta large
    delta = 1;
    
     %newton rapson iterations -> J*delta = -G
    while(delta > epsilon)
        % 1x1           1                           1x1
        delta = jac(y_np1,h(i))^-1  * -g(y_np1,y_n,h(i),t + h(i)); 
        y_np1 = y_np1 + delta;
    end
    
    % append values to plot variables
    yt(j) = y_np1;
    j = j + 1;
    
    %increment y
    y_n = y_np1;
   
end

%store difference between final numerical and analytical solution
error1(i) = abs(y_ana(t) - y_n); 

% %plot x,y,t
% hold on
% plot(tVect,yt);
% title('numerical approximations of decreasing step size h')

end

figure;
plot(log2(h),log2(error1), '-bs');
title('convergence Analysis, Backwards Euler')
xlabel('log2(h)')
ylabel('log2(error) @ t = 10 seconds')


%% C) generate a convergence plot for an order 4 BDF which approximates the
%solution of the above IVP

%BDF co-efficients: 
A = [48/25 -36/25 16/25 -3/25]; %alpha values
B = [12/25]; %beta values

%constants:
h = [.05 .01 .005 .001]; %decreasing values of h
tStart =1; %sec
tEnd = 10; %sec
epsilon =.0001;

%initial conditions:
y1 = 1;

%functions
y_ana = @(t)  1/t + 1/t^2*(tan(1/t + pi -1)); %analytical expression for y
ydot  = @(y_n,t) -y_n^2 - 1/t^4;
jac   = @(y_n,h) 1 + h*12/25*2*y_n; %jacobian = d/dy_n(g)
g     = @(y,h,t,n) y(n) - A(1)*y(n-1) - A(2)*y(n-2) - A(3)*y(n-3) - A(4)*y(n-4) - B*h*ydot(y(n), t);
 
for i = 1:length(h);

%reset initial conditions and plot variables   
tVect = tStart:h(i):tEnd;
y = zeros(length(tVect),1);
j = 1; %plot counter
n = 5; %5th time step
tstart = tStart + n * h(i); %start BDF at 5th time step

%use the analytical solution to prime the BDF method 
for ind = 1:4
    y(ind) = y_ana(tStart + (ind - 1)*h(i));
end

for t = tstart:h(i):tEnd %start:step:stop
  
    %use forward euler to generate first guess of Y_n
    y(n) = A(1)*y(n-1) + A(2)*y(n-2) + A(3)*y(n-3) + A(4)*y(n-4) + B*h(i)*ydot(y(n-1),(t - h(i)));
    
    %set delta large
    delta = 0;
    
     %newton rapson iterations -> J*delta = -G
    while(abs(delta) > epsilon)
        % 1x1           1                           1x1
        delta = jac(y(n),h(i))^-1  * -g(y,h(i),t,n); 
        y(n)= y(n) + delta;
    end
    
    %increment n
    n = n + 1;
   
end

%store difference between (4th)from final numerical and analytical solution
error2(i) = abs(y_ana(t -4*h(i)) - y(n-4)); 

% %plot x,y,t
% hold on
% plot(tVect,y);
% title('numerical approximations of decreasing step size h')

end

%figure;
plot(log2(h),log2(error2), '-rs');
title('convergence Analysis BDF order 4')
xlabel('log2(h)')
ylabel('log2(error) @ t = 10 seconds')


%% compare BDF order 4 to Backwards Euler

%by inspection, the BDF of order 4 seems to have less error at the same
%step size the slopes seem to converging, like the lines will cross at high
%step size

plot(log2(h),log2(error2), '-rs');
title('convergence Analysis BDF order 4')
xlabel('log2(h)')
ylabel('log2(error) @ t = 10 seconds')

hold on 

plot(log2(h),log2(error1), '-bs');
title('convergence Analysis, Backwards Euler')
xlabel('log2(h)')
ylabel('log2(error) @ t = 20seconds')

##### SOURCE END #####
--></body></html>